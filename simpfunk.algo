Librairie
# Simpfunk:
# + flip bit
# . add bit to buffer
# : print buffer and clear

Variable one_bit en Entier
Variable buffer en Chaîne

Procédure reset()
  one_bit <- 0
  buffer  <- ""
FinProcédure

Fonction bin_pad(char en Caractère) en Chaîne
  # H → 72 → 100100 → 0100100
  Variable chars en Caractère*2
  Variable cc en Entier
  Variable res en Chaîne
  chars <- "01"
  cc <- CodeCar(char)
  res <- ""
  TantQue cc > 0
    res <- Extraire(chars, cc % 2 + 1, 1) & res
    cc <- cc / 2
  FinTantQue
  TantQue Longueur(res) < 8
    res <- "0" & res
  FinTantQue
  Retourne res
FinFonction

Fonction to_funk(string en Chaîne, one, raw en Booléen) en Chaîne
  # H → 72 → 0100100 → .+.+..+.+..
  Variables bits, program en Chaîne
  Variables bit, idx1, idx2 en Entier
  bits <- ""
  program <- ""
  bit <- 0
  Pour idx1 <- 1 à Longueur(string)
    bits <- bin_pad(Extraire(string, idx1, 1))
    Pour idx2 <- 1 à 8
      Si Extraire(bits, idx2, 1) = "0" Alors
        Si bit = 0 Alors
          program <- program & "."
        Sinon
          program <- program & "+."
        FinSi
        bit <- 0
      Sinon
        Si bit = 1 Alors
          program <- program & "."
        Sinon
          program <- program & "+."
        FinSi
        bit <- 1
      FinSi
    idx2 Suivant

    Si one Alors
      program <- program & ":"
    FinSi

  idx1 Suivant

  Si NON(one) Alors
    program <- program & ":"
  FinSi

  Si raw Alors
    Retourne program
  Sinon
    Retourne compress(program)
  FinSi

FinFonction

Fonction compress(prog en Chaîne) en Chaîne
  # LZ78 compression
  # 01000001 → .+.+.....+. → 0.0+1+1.4.2.0:
  Structure Entry
    entry en Chaîne
    value en Entier
  FinStructure

  Tableau dict[0] en Entry
  Variables i, idx, e_idx, cpt en Entier
  Variables c, ch, out en Chaîne
  Variables start, end en Numérique

  Fonction entry_index(name en Chaîne, entries[] en Entry) en Entier
    Variable i en Entier
    Pour i <- 0 à Taille(entries) - 1
      Si entries[i].entry = name Alors
        Retourne i
      FinSi
    i Suivant
    Retourne -1
  FinFonction

  start <- TempsUnix()
  EcrireErr "Compressing..."

  cpt <- 0
  idx <- 0
  ch <- ""
  out <- ""
  dict[0] <- "", 0

  Pour i <- 1 à Longueur(prog)
    c <- Extraire(prog, i, 1)
    ch <- ch & c
    e_idx <- entry_index(ch, dict)
    Si e_idx <> -1 Alors
      cpt <- dict[e_idx].value
    Sinon
      out <- out & Chaîne(cpt) & c
      cpt <- 0
      idx <- idx + 1
      Redim dict[Taille(dict)]
      dict[Taille(dict) - 1] <- ch, idx
      ch <- ""
    FinSi
    EcrireErr "\033[K" & Chaîne(Taille(dict)) & " " & dict[Taille(dict) - 1].entry & "\r" \
  i Suivant

  EcrireErr ""

  Si ch <> "" Alors
    out <- out & Chaîne(cpt)
  FinSi

  end <- TempsUnix()
  EcrireErr "Compressed", 100 - (Longueur(out) / Numérique(Longueur(prog)) * 100)  ,"% in", end - start, "seconds."

  Retourne out
FinFonction

Fonction decompress(prog en Chaîne, verbose en Booléen) en Chaîne
  Structure Entry
    entry en Entier
    value en Chaîne
  FinStructure

  Tableau dict[0] en Entry
  Variables i, idx, e_idx en Entier
  Variables n, c, ch, out en Chaîne
  Variables start, end en Numérique

  Fonction entry_index(name en Chaîne, entries[] en Entry) en Entier
    Variable i en Entier
    # Erreur si chaîne vide! Fichier probablement non compressé.
    Si name = "" Alors
      Si verbose Alors
        EcrireErr "ERROR : this file is not compressed."
      FinSi
      Retourne -2
    FinSi
    Pour i <- Taille(entries) - 1 à 0 Pas -1
      Si entries[i].entry = Entier(name) Alors
        Retourne i
      FinSi
    i Suivant
    Retourne -1
  FinFonction

  Fonction is_digit(car en Caractère) en Booléen
    Retourne CodeCar(car) >= 48 ET CodeCar(car) <= 57
  FinFonction

  Si verbose Alors
    start <- TempsUnix()
    EcrireErr "Decompressing..."
  FinSi

  idx <- 1
  ch <- ""
  n <- ""
  out <- ""
  dict[0] <- 0, ""

  Pour i <- 1 à Longueur(prog)
    c <- Extraire(prog, i, 1)
    Si is_digit(c) Alors
      n <- n & c
    Sinon
      e_idx <- entry_index(n, dict)
      Si e_idx = -2 Alors
        # Fichier non compressé, retourné tel quel.
        Retourne prog
      FinSi
      ch <- dict[e_idx].value & c
      Redim dict[Taille(dict)]
      dict[Taille(dict) - 1] <- idx, ch
      idx <- idx + 1
      n <- ""
    FinSi
    Si verbose Alors
      EcrireErr "\033[K" & Chaîne(Taille(dict)) & " " & dict[Taille(dict) - 1].value & "\r" \
    FinSi
  i Suivant

  Pour i <- 0 à Taille(dict) - 1
    out <- out & dict[i].value
  i Suivant

  Si n <> "" Alors
    e_idx <- entry_index(n, dict)
    out <- out & dict[e_idx].value
  FinSi

  Si verbose Alors
    Ecrire ""
    end <- TempsUnix()
    EcrireErr "Decompressed in", end - start, "seconds."
  FinSi

  Retourne out
FinFonction

Fonction get_chars() en Chaîne
  # 0100100 → 72 → H
  Variable chars en Caractère*2
  Variables sub_buf, string en Chaîne
  Variables idx1, idx2, res en Entier
  chars <- "01"
  string <- ""
  Pour idx1 <- 1 à Longueur(buffer) Pas 8
    res <- 0
    sub_buf <- Extraire(buffer, idx1, 8)
    Pour idx2 <- 1 à 8
      res <- res * 2
      res <- res + Trouve(chars, Extraire(sub_buf, idx2, 1)) - 1
    idx2 Suivant
    string <- string & Car(res)
  idx1 Suivant
  Retourne string
FinFonction

Procédure flip()
  # +
  Si one_bit = 0 Alors
    one_bit <- 1
  Sinon
    one_bit <- 0
  FinSi
FinProcédure

Procédure get_bit()
  # .
  buffer <- buffer & Chaîne(one_bit)
FinProcédure

Procédure print()
  # :
  Ecrire get_chars() \
  buffer <- ""
FinProcédure

Fonction execute(cprog en Chaîne) en Booléen
  Variable idx en Entier
  Variable cmd en Caractère
  Variable prog en Chaîne

  reset()

  prog <- decompress(cprog, FAUX)

  Pour idx <- 1 à Longueur(prog)
    cmd <- Extraire(prog, idx, 1)
    Si cmd = "+" Alors
      flip()
    SinonSi cmd = "." Alors
      get_bit()
    SinonSi cmd = ":" Alors
      print()
    Sinon
      EcrireErr "SYNTAX ERROR: line #", idx
      EcrireErr "++ Invalid character >", cmd, "<"
      Retourne FAUX
    FinSi
  idx Suivant
  Ecrire ""
  Retourne VRAI
FinFonction

